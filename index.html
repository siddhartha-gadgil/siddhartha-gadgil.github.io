
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Automating Mathematics</title>
  <meta name="author" content="Siddhartha Gadgil">

  
  <meta name="description" content="A single lambda island We are given a type $T$. Generate a new variable $x : T$. The result and gradient do not depend on $x$ (upto equality). We &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://siddhartha-gadgil.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Automating Mathematics" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Automating Mathematics</a></h1>
  
    <h2>Working journal</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:siddhartha-gadgil.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/16/lambda-islands/">Lambda Islands</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-16T15:51:20+05:30" pubdate data-updated="true">Jan 16<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="a-single-lambda-island">A single lambda island</h2>

<ul>
  <li>We are given a type $T$.</li>
  <li>Generate a new variable $x : T$. The result and gradient do not depend on $x$ (upto equality).</li>
  <li>We have an inclusion map $i_x: FD(V) \to FD(V)$. This is almost the identity, except the gradient purges the weight of $x$.</li>
  <li>From this we get the initializer on distributions, introducing $x$ with weight $p(m)$ with $m$ the $\lambda$-parameter and scaling the rest by $1 - p(m)$.</li>
  <li>It is probably easiest to directly define the initializer, defining its application and gradient.</li>
  <li>We compose the initializer with a given dynamical system.</li>
  <li>Finally, export by mapping $y$ to $x \mapsto y$. This is composed with the initializer and the given dynamical system.</li>
</ul>

<h2 id="combining-lambda-islands">Combining lambda islands.</h2>

<ul>
  <li>Given an initial distribution, we have weights $p(T)$ associated to each type $T$.</li>
  <li>Given a dynamical system $f$ and type $T$, we have a new system $\Lambda_T(f)$.</li>
  <li>We take the weighted sum of these, i.e., $\Lambda(f) = \sum_T w(T) \Lambda_t(f)$.</li>
</ul>

<h2 id="using-recurrence">Using recurrence</h2>

<ul>
  <li>Given a dynamical system, generate a family $g_k$ indexed by natural numbers $k$ corresponding to iterating $2^k$ times.</li>
  <li>Mix in lambda to get a new family $f_k$ with $f_k = g_k + \Lambda(f_{k-1})$, with the last term a priori vanishing for $k \leq 0$.</li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/12/dynamical-actors/">Dynamical Actors</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-12T09:44:57+05:30" pubdate data-updated="true">Jan 12<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="context">Context</h2>

<ul>
  <li>Dynamical system $f: X\to X$ depending on parameters.</li>
  <li>Goals to check.</li>
</ul>

<h2 id="worker">Worker</h2>

<ul>
  <li>Called with state, parameter,iterations, goals.</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line">  <span class="k">case</span> <span class="k">class</span> <span class="nc">LoopWork</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">X</span><span class="o">,</span> <span class="n">p</span><span class="k">:</span> <span class="kt">P</span><span class="o">,</span> <span class="n">loops</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">goals</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="nc">List</span><span class="o">())</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>Iterates until success or loops completed.</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line">  <span class="k">case</span> <span class="k">class</span> <span class="nc">LoopsDone</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">final</span> <span class="k">:</span> <span class="kt">X</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">  <span class="k">case</span> <span class="k">class</span> <span class="nc">Success</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">final</span> <span class="k">:</span> <span class="kt">X</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="database">Database</h2>

<ul>
  <li>commits</li>
  <li>solutions: commit, goal.</li>
  <li>goals</li>
</ul>

<h3 id="commits">Commits</h3>

<ul>
  <li>State</li>
  <li>Hash-tag : string representing hex code of hash-tag</li>
  <li>Ancestor</li>
  <li>Meta-data: who committed, why.</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line">  <span class="k">def</span> <span class="n">commit</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">X</span><span class="o">,</span> <span class="n">parent</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">:</span> <span class="kt">String</span> <span class="c1">// returns hash-tag</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="hub">Hub</h2>

<ul>
  <li>Maintains all workers and communication with outside. Messages (and a few similar ones).</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line">  <span class="k">case</span> <span class="k">object</span> <span class="nc">ActorList</span> <span class="c1">// returns actor ids and whether they are paused.</span>
</span><span class="line">
</span><span class="line">  <span class="k">case</span> <span class="k">class</span> <span class="nc">QueryState</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">pause</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">  <span class="k">case</span> <span class="k">class</span> <span class="nc">QueryParams</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="c1">// look up parameters at hub.</span>
</span><span class="line">
</span><span class="line">  <span class="k">case</span> <span class="k">class</span> <span class="nc">UpdateParams</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">p</span><span class="k">:</span> <span class="kt">P</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">  <span class="k">case</span> <span class="k">class</span> <span class="nc">UpdateState</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">x</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">  <span class="k">case</span> <span class="k">class</span> <span class="nc">PauseWorker</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">  <span class="k">case</span> <span class="k">class</span> <span class="nc">ResumeWorker</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">  <span class="k">case</span> <span class="k">class</span> <span class="nc">StopWorker</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">  <span class="k">case</span> <span class="k">class</span> <span class="nc">UpdateGoals</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">goals</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">X</span> <span class="k">=&gt;</span> <span class="kt">Boolean</span><span class="o">])</span>
</span><span class="line">
</span><span class="line">  <span class="k">case</span> <span class="k">class</span> <span class="nc">ActorLoops</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">loops</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>For simplicity, assume that pausing on success is independent of actor, and pausing on query is part of the query string.</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line">  <span class="k">case</span> <span class="k">class</span> <span class="nc">ActorState</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">X</span><span class="o">,</span> <span class="n">p</span><span class="k">:</span> <span class="kt">P</span><span class="o">,</span>
</span><span class="line">    <span class="n">loops</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
</span><span class="line">    <span class="n">paused</span> <span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span>
</span><span class="line">    <span class="n">lastCommit</span><span class="k">:</span> <span class="kt">Long</span>
</span><span class="line">    <span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="callback-on-success">Callback on success</h3>

<ul>
  <li>Commit the state.</li>
  <li>Record that the commit contains a success.</li>
  <li>Possibly update goals removing those attained.</li>
  <li>SSE log the goals.</li>
</ul>

<h2 id="channels">Channels</h2>

<ul>
  <li>from interface: post JSON to server.</li>
  <li>to interface: send SSE with <em>type</em> used for a switch to decide action.</li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/09/feedbacks/">Feedbacks</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-09T12:03:51+05:30" pubdate data-updated="true">Jan 9<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="feedbacks">Feedbacks</h2>

<ul>
  <li>A feedback is a function $f: X \to X$, typically depending on parameters, but which is <em>not</em> differentiable (i.e., no gradient).</li>
</ul>

<h2 id="combinators">Combinators</h2>

<ul>
  <li><em>Linear Structure:</em> We can define a linear structure on <em>A =&gt; B</em> given one on <em>B</em>. This does not collide with that on differentiable functions as linear structures are not covariant.</li>
  <li><em>Conjugation</em>: Given a differentiable function $f: X \to Y$ and a (feedback) function $g: Y\to Y$, we can define a conjugate function $g^f: X\to X$ by</li>
</ul>

<script type="math/tex; mode=display">g^f(x) = \Delta f(x)(g(f(x))).</script>

<ul>
  <li>This behaves well with respect to composition of differentiable functions and linear combinations of feedbacks.</li>
  <li><em>Partial conjugation:</em> Sometimes the feedback also depends on $x \in X$, so we have $g: X\to Y$. We are then back-propagating $g$ using $f$.</li>
</ul>

<h2 id="matching-distributions">Matching distributions:</h2>

<ul>
  <li>Given a target distribution on $Y$, we get a feedback towards the target.</li>
  <li>Given a distribution on $X$ and $f: X\to Y$, we have a pushforward distribution. We get an image feedback.</li>
  <li>To get a feedback on $X$, we need to distribute among all terms with a given image proportional to the term, or depending only on the coefficient of the image image.</li>
  <li><strong>Question</strong> Can we define this shift on $X$ in one step correctly?</li>
  <li><strong>Gradient view:</strong> Just view $f$ as a differentiable function and back-propagate by the gradient. This shifts weights independently.</li>
</ul>

<h2 id="terms-matching-types">Terms matching types</h2>

<ul>
  <li>We compare the distribution of terms that are types with the map from terms to types.</li>
  <li>The difference between these gives a flow on types.</li>
  <li>We back-propagate to get a flow on terms.</li>
</ul>

<h2 id="approximate-matches">Approximate matches</h2>

<ul>
  <li>We can filter by having a specific type, and then an error matching having a refined type (after some function application).</li>
  <li>For a given term, we get the product of its weight with an error factor.</li>
  <li>In terms of combinators, we replace inclusion by a weighted inclusion, or a product of the inclusion with a <em>conformal factor</em>. We need a new basic differentiable function.</li>
</ul>

<h2 id="blending-feedbacks">Blending feedbacks.</h2>

<ul>
  <li>As in the case of matching types, suppose
    <ul>
      <li>$X$ is a finite distribution.</li>
      <li>various feedbacks are based on atoms.</li>
      <li>we have weights for the various feedbacks.</li>
    </ul>
  </li>
  <li>We give more credit for feedback components attained by fewer terms.</li>
  <li>This is achieved by sharing the feedback coming from one component, instead of just giving gradient</li>
  <li>The <em>terms representing types</em> feedback is a special instance of this.</li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/07/blending-pruning-and-backprop/">Blending Pruning and Backprop</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-07T10:25:14+05:30" pubdate data-updated="true">Jan 7<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="the-problem">The problem</h2>

<ul>
  <li>One way to evolve a system is the <em>genetic algorithm</em> style, where we consider the fitness of the <em>final</em> elements and prune based on this. This however has trivial credit assignment.</li>
  <li>At the other extreme is a pure back-propogation. This has nice credit assignment, but done directly the support never changes.</li>
</ul>

<h2 id="solution">Solution</h2>

<ul>
  <li>Firstly, there must be an identity term in the evolution, so credit <em>can</em> go to objects just persisting.</li>
  <li>Note that while the result of a big sum does not depend on terms that are zero, specifically $\mu(v)f$ with $\mu(v) = 0$, the gradient still depends on such terms. Specifically we can get a flow back to add weight to $v$  </li>
  <li>We <em>decouple</em> the big sum component, so that when we apply to an argument which is a distribution, we do not just take a set of functions depending on that distribution. We can instead take a specified support.</li>
  <li>We take a big sum over all generated elements, to allow some of them to acquire weight, while computing the gradient.</li>
  <li>We should periodically prune by weight, but only after flowing for long enough to allow for picking up weight.</li>
</ul>

<h2 id="code">Code</h2>

<ul>
  <li>We consider differentiable functions that also depend on a subset of V, by taking linear combinations including bigsums that are the <em>union</em> of the support of a distribution with the given subset.</li>
  <li>For propagation, we just take an empty subset of V.</li>
  <li>Once we have the image, we take its (essential) support as the given subset of V. We recompute the differentiable function. Note that the value is unchanged.</li>
  <li>We use the gradient of the new function to back-propagate.</li>
  <li>This gives a single loop, which we repeat to evolve the system.</li>
  <li>Purge after looping for enough time.</li>
</ul>

<h2 id="using-the-identity">Using the identity</h2>

<ul>
  <li>The gradient of the <strong>identity</strong> does not depend on any form of <em>a priori</em> support.</li>
  <li>Hence the gradient of a persistence term, i.e., identity multiplied by a weigh, attributes weight to everything in the final distribution.</li>
  <li><strong>Note:</strong> This lets us avoid the above complications.  </li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/02/differentiable-function-combinators/">Differentiable Function Combinators</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-02T15:24:10+05:30" pubdate data-updated="true">Jan 2<span>nd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="basic-functions-and-combinators-all-implemented">Basic functions and Combinators (all implemented)</h2>

<p>We build differentiable functions for our basic learning system using some basic ones and combinators:</p>

<ul>
  <li>compositions (in class)</li>
  <li>sums and scalar products of differentiable functions. (done)</li>
  <li>product of a real valued and a vector valued function - the subtlest case (done).</li>
  <li>identity function (done).</li>
  <li>projections on (V, W) (done)</li>
  <li>inclusions to (V, W) (dome)</li>
  <li>evaluation of a finite distribution at a point (done).</li>
  <li>atomic distribution as a function of weight (done).</li>
  <li>point-wise multiplication of a finite distribution by a given function (done).</li>
  <li>sum of a set of functions, with even the set depending on argument (done).
    <ul>
      <li>this can be interpreted as the sum of a fixed set of functions, but with all but finitely many  zero.</li>
    </ul>
  </li>
  <li>repeated squaring $k$ times, with $k=0$ and $k&lt;0$ cases (done).</li>
  <li>recursive definitions for families indexed by integers - generic given zero. Done (for vector spaces).</li>
</ul>

<h2 id="derived-from-these">Derived from these</h2>

<ul>
  <li>(optional) moves</li>
  <li>(optional) pairings</li>
  <li>linear combinations.</li>
</ul>

<h2 id="convenience-code">Convenience code</h2>

<ul>
  <li>Have implicit conversion from
    <ul>
      <li>a type T implicitly depending on a linear structure on T to have methods ++ and *:</li>
      <li>DiffbleFunction[V, V] to a class with a multiplication method **:</li>
    </ul>
  </li>
</ul>

<h3 id="to-do">To Do:</h3>

<ul>
  <li>Construct differentiable functions for Finite Distributions - atom, evaluate and point-wise product.</li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/02/gradient-of-product/">Gradient of Product</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-02T10:38:10+05:30" pubdate data-updated="true">Jan 2<span>nd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>A subtle differentiable function is the scalar product,</p>

<script type="math/tex; mode=display">f: (\alpha, v) \mapsto \alpha v</script>

<p>for a vector space $V$.</p>

<h2 id="derivative">Derivative</h2>

<p>By Liebniz rule,  the total derivative is</p>

<script type="math/tex; mode=display">Df(\alpha, v)(\alpha', v') = \alpha v' + \alpha' v</script>

<h2 id="gradient">Gradient</h2>

<p>Note that depends on the vector space structure on $(\mathbb{R}, V)$. For a vector $w$ in $V$, note that we can write</p>

<script type="math/tex; mode=display">% <![CDATA[
<Df(\alpha, v)(\alpha', v'), w> = \alpha' <v, w> + <v', \alpha w> = <(\alpha', w'), (<v, w>, \alpha w) %]]></script>

<p>By definition of gradient (as adjoint derivative), we have</p>

<script type="math/tex; mode=display">% <![CDATA[
\Delta f (\alpha, v)(w) = (<v, w>, \alpha w) %]]></script>

<h2 id="code">Code</h2>

<p>We need an additional implicit structure with combinators:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">case</span> <span class="k">class</span> <span class="nc">InnerProduct</span><span class="o">[</span><span class="kt">V</span><span class="o">](</span><span class="n">dot</span><span class="k">:</span> <span class="o">(</span><span class="kt">V</span><span class="o">,</span> <span class="kt">V</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Double</span><span class="o">)</span>
</span><span class="line">
</span><span class="line"><span class="k">def</span> <span class="n">vdot</span><span class="o">[</span><span class="kt">V</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ip</span><span class="k">:</span> <span class="kt">InnerProduct</span><span class="o">[</span><span class="kt">V</span><span class="o">])</span> <span class="k">=</span> <span class="n">ip</span><span class="o">.</span><span class="n">dot</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/31/linear-structure-implicits/">Linear Structure, Differentiable Functions (Implicit) Combinators</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-31T08:52:22+05:30" pubdate data-updated="true">Dec 31<span>st</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>The best way to build differentiable functions for the typical learning system in function-finder is using <em>combinators</em>. At present there is some ad hoc version of this. The better way is to use linear structures systematically.</p>

<h2 id="linear-structures">Linear structures</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">case</span> <span class="k">class</span> <span class="nc">LinearStructure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">sum</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">mult</span> <span class="k">:</span> <span class="o">(</span><span class="kt">Double</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">){</span>
</span><span class="line">  <span class="k">def</span> <span class="n">diff</span><span class="o">(</span><span class="n">frm</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">remove</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="n">sum</span><span class="o">(</span><span class="n">frm</span><span class="o">,</span> <span class="n">mult</span><span class="o">(-</span><span class="mf">1.0</span><span class="o">,</span> <span class="n">remove</span><span class="o">))</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Linear Spaces can be built with</p>

<ul>
  <li>Real numbers - Double</li>
  <li>Finite Distributions have ++ and *</li>
  <li>Pairs of linear spaces</li>
  <li>Differentiable functions between linear spaces</li>
  <li>(Eventually) Maps with values in Linear spaces - for representation learning.</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">case</span> <span class="k">class</span> <span class="nc">LinearStructure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">sum</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">mult</span> <span class="k">:</span> <span class="o">(</span><span class="kt">Double</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">){</span>
</span><span class="line">  <span class="k">def</span> <span class="n">diff</span><span class="o">(</span><span class="n">frm</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">remove</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="n">sum</span><span class="o">(</span><span class="n">frm</span><span class="o">,</span> <span class="n">mult</span><span class="o">(-</span><span class="mf">1.0</span><span class="o">,</span> <span class="n">remove</span><span class="o">))</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="k">implicit</span> <span class="k">val</span> <span class="nc">RealsAsLinearStructure</span> <span class="k">=</span> <span class="nc">LinearStructure</span><span class="o">[</span><span class="kt">Double</span><span class="o">]((</span><span class="k">_</span><span class="o">+</span><span class="k">_</span><span class="o">),</span> <span class="o">(</span><span class="k">_</span><span class="o">*</span><span class="k">_</span><span class="o">))</span>
</span><span class="line">
</span><span class="line"><span class="k">implicit</span> <span class="k">def</span> <span class="nc">VectorPairs</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">lsa</span><span class="k">:</span> <span class="kt">LinearStructure</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">lsb</span><span class="k">:</span> <span class="kt">LinearStructure</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">LinearStructure</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class="line">  <span class="k">def</span> <span class="n">sumpair</span><span class="o">(</span><span class="n">fst</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">),</span> <span class="n">scnd</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">))</span> <span class="o">=(</span><span class="n">lsa</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="n">fst</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">scnd</span><span class="o">.</span><span class="n">_1</span><span class="o">),</span> <span class="n">lsb</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="n">fst</span><span class="o">.</span><span class="n">_2</span><span class="o">,</span> <span class="n">scnd</span><span class="o">.</span><span class="n">_2</span><span class="o">))</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">multpair</span><span class="o">(</span><span class="n">sc</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">vect</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">))</span> <span class="k">=</span> <span class="o">(</span><span class="n">lsa</span><span class="o">.</span><span class="n">mult</span><span class="o">(</span><span class="n">sc</span><span class="o">,</span> <span class="n">vect</span><span class="o">.</span><span class="n">_1</span><span class="o">),</span> <span class="n">lsb</span><span class="o">.</span><span class="n">mult</span><span class="o">(</span><span class="n">sc</span><span class="o">,</span> <span class="n">vect</span><span class="o">.</span><span class="n">_2</span><span class="o">))</span>
</span><span class="line">
</span><span class="line">  <span class="nc">LinearStructure</span><span class="o">(</span><span class="n">sumpair</span><span class="o">,</span> <span class="n">multpair</span><span class="o">)</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="k">implicit</span> <span class="k">def</span> <span class="nc">FiniteDistVec</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">LinearStructure</span><span class="o">[</span><span class="kt">FiniteDistribution</span><span class="o">[</span><span class="kt">T</span><span class="o">]](</span><span class="k">_</span><span class="o">++</span><span class="k">_</span><span class="o">,</span> <span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">d</span> <span class="o">*</span> <span class="n">w</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="to-do">To Do:</h3>

<ul>
  <li>Add a field for the zero vector (done).</li>
  <li>Create a linear structure for differentiable functions(done).</li>
  <li>Have functions that implicitly use linear structures(done).</li>
</ul>

<h2 id="more-vector-structures">More vector structures</h2>

<p>In addition, we need <em>inner products</em> for computing certain gradients as well as <em>totals</em> for normalization. These are built for</p>

<ul>
  <li>Finite distributions</li>
  <li>pairs</li>
  <li>Real numbers</li>
  <li>(Eventually) Maps with co-domain having inner products and totals.</li>
</ul>

<h2 id="differentiable-functions">Differentiable functions</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class="scala"><span class="line"><span class="k">trait</span> <span class="nc">DiffbleFunction</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">(</span><span class="n">A</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">){</span><span class="n">self</span> <span class="k">=&gt;</span>
</span><span class="line">  <span class="k">def</span> <span class="n">grad</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span>
</span><span class="line">
</span><span class="line">  <span class="cm">/**</span>
</span><span class="line"><span class="cm">  * Composition f *: g is f(g(_))</span>
</span><span class="line"><span class="cm">  */</span>
</span><span class="line">  <span class="k">def</span> <span class="o">*:[</span><span class="kt">C</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="kt">DiffbleFunction</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">])</span> <span class="k">=</span> <span class="n">andThen</span><span class="o">(</span><span class="n">that</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">  <span class="k">def</span> <span class="n">andThen</span><span class="o">[</span><span class="kt">C</span><span class="o">](</span><span class="n">that</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">DiffbleFunction</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">DiffbleFunction</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="nc">DiffbleFunction</span><span class="o">((</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">that</span><span class="o">(</span><span class="k">this</span><span class="o">(</span><span class="n">a</span><span class="o">)))(</span>
</span><span class="line">    <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class="line">    <span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">C</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class="line">    <span class="n">grad</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="n">that</span><span class="o">.</span><span class="n">grad</span><span class="o">(</span><span class="k">this</span><span class="o">(</span><span class="n">a</span><span class="o">))(</span><span class="n">c</span><span class="o">)))</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">
</span><span class="line">  <span class="k">object</span> <span class="nc">DiffbleFunction</span><span class="o">{</span>
</span><span class="line">    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="n">grd</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">B</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">))</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">DiffbleFunction</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]{</span>
</span><span class="line">      <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">      <span class="k">def</span> <span class="n">grad</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="n">grd</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Differentiable functions are built from</p>

<ul>
  <li>Composing and iterating differentiable functions.</li>
  <li>(Partial) Moves on X giving FD(X) -&gt; FD(X)</li>
  <li>(Partial) Combinations on X giving FD(X) -&gt; FD(X)</li>
  <li>Co-ordinate functions on FD(X).</li>
  <li>Inclusion of a basis vector.</li>
  <li>Projections and Inclusions for pairs.</li>
  <li>Scalar product of differentiable functions, $x\mapsto f(x) * g(x)$ with $f: V \to \mathbb{R}$ and $g: V\to W$.</li>
  <li>The sum of a set of differentiable functions X \to Y, with the set of functions depending on $x : X$.</li>
</ul>

<p>From the above, we should be able to build.</p>

<ul>
  <li><strong>Islands:</strong> Recursive definitions in terms of the function itself - more precisely a sequence of functions at different <em>depths</em> (in a more rational form).</li>
  <li><strong>Multiple islands:</strong> A recurrence corresponding to a lot of island terms.</li>
</ul>

<h3 id="to-do-1">To Do:</h3>

<ul>
  <li>Clean up the present ad hoc constructors replacing them by combinators.</li>
</ul>

<h2 id="islands">Islands</h2>

<ul>
  <li>After adding an island, we get a family of differentiable functions $f_d$ indexed by depth.</li>
  <li>This can be simply viewed as a recursive definition.</li>
  <li>
    <p>Given a function $g$, we get a function at depth $d$ by iterating $2^d$ times by repeated squaring.</p>
  </li>
  <li>
    <p>Determined by:</p>

    <ul>
      <li>An initial family of differentiable functions $g_d$, corresponding to iterating $2^d$ times.</li>
      <li>A transformation on differentiable functions $f \mapsto L(f)$.</li>
    </ul>
  </li>
  <li>
    <p>Recurrence relation:</p>

    <ul>
      <li>$f_d = g_d + L(f_{d-1})$, for $d \geq 0$, with $f_{-1} = 0$.</li>
      <li>Here $L(f) = i \circ f \circ j$.</li>
      <li>When $d=0$, the recurrence relation just gives just gives $id = id$.</li>
      <li>Then $d=1$, we get $f_1 = g_1 + L(id)$.</li>
    </ul>
  </li>
</ul>

<h2 id="multiple-islands">Multiple Islands</h2>

<ul>
  <li>We have a set of islands associated to a collection of objects, with a differentiable function associated to each.</li>
  <li>We can assume the set to be larger, with functions for the rest being zero. So the set is really an a priori bound.</li>
  <li>We get a recurence relation:</li>
  <li>$f_d(\cdot) = g_d(\cdot) + \sum_v i_v(\cdot) * L_v(f_{d-1}(\cdot)).$</li>
  <li>Here $i_v$ is evaluation at $v$, for a pair of finite distributions.</li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/31/quasi-literate-programming/">Quasi-literate Programming</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-31T08:39:41+05:30" pubdate data-updated="true">Dec 31<span>st</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This blog will now have various comments, often technical, concerning the issues I face while working, mainly programming for Automated theorem proving.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/21/moving-blogs/">Moving Blogs</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-21T10:09:44+05:30" pubdate data-updated="true">May 21<span>st</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>The blog “Logic, Types and Spaces” has moved to:</p>

<p><a href="http://siddhartha-gadgil.github.io/LogicTypesSpaces/">http://siddhartha-gadgil.github.io/LogicTypesSpaces/</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/26/logic-from-types/">Logic From Types</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-26T06:46:59+05:30" pubdate data-updated="true">Mar 26<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>At the core of homotopy type theory (and its predecessors) is the idea of <em>propostions as types</em>. Namely, we interpret logical propositions - statements that are either true or false, as types, with a proposition being true if and only if the corresponding type has an element (i.e., there is an object with that type). The Curry-Howard correspondence lets us embed all of logic into type theory in the manner. </p>

<h3 id="true-and-false">True and False</h3>

<p>We begin by representing the two simplest propositions: true - always true,  and false.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>True and False types
</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">True</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">qed</span> <span class="kt">:</span> <span class="kt">True</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="kr">data</span> <span class="kt">False</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The $True$ type has just one constructor, giving an object with type $True$. On the other hand, the $False$ type has no constructors, so there are no objects of type $False$.</p>

<p>There are various ways of building propositions from other propositions. We see how these translate to constructions of types.</p>

<h3 id="logical-implies">Logical implies</h3>

<p>If $P$ and $Q$ are propositions, which we identify with their corresponding types. We interpret the proposition $P \implies Q$ as the function type $P \to Q$.</p>

<h3 id="some-deductions">Some deductions</h3>

<p><em>Modus Poens</em> is the rule of deduction (due to Aristotle) that says that if the proposition $P$ is true, and $P$ implies $Q$, then $Q$ is true. We can prove this in the types interpretation. Namely, Modus Poens transaltes to the statement that if we have an objects of type $P$ and $P \to Q$, then we have an object of type $Q$. We get an object of type $Q$ by function application.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Modus Poens
</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">moduspoens</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">P</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="kt">Q</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">P</span> <span class="err">→</span> <span class="p">(</span><span class="kt">P</span> <span class="err">→</span> <span class="kt">Q</span><span class="p">)</span> <span class="err">→</span> <span class="kt">Q</span>
</span><span class="line"><span class="nf">moduspoens</span> <span class="n">p</span> <span class="n">imp</span> <span class="ow">=</span> <span class="n">imp</span> <span class="n">p</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Next, we see my favourite method of proof - vacuous implication. This says that a false statement implies everything, i.e., for any proposition $P$, we have $False \implies P$, which in type theory says $False\to P$ has objects.</p>

<p>As the $False$ type has no cases at all, a function is defined on $False$ by using an absurd pattern, which just says that there are no cases, so no definition is needed.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Vacuous implication
</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">vacuous</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="kt">False</span> <span class="err">→</span> <span class="kt">A</span>
</span><span class="line"><span class="nf">vacuous</span> <span class="nb">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="even-and-odd-numbers">Even and Odd numbers</h3>

<p>Next, we define a type family Even n which is non-empty if and only if n is even. To do this, we see that a number is even if and only if it is even as a consequence of the rules</p>

<ul>
  <li>$0$ is even.</li>
  <li>If $n$ is even, so is $n + 2$.</li>
  <li>Thus, we can define the inductive type family:</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Even type family
</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Even</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">zeroeven</span> <span class="kt">:</span> <span class="kt">Even</span> <span class="n">zero</span>
</span><span class="line">  <span class="o">+</span><span class="mi">2</span><span class="n">even</span> <span class="kt">:</span> <span class="p">{</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">}</span> <span class="err">→</span> <span class="kt">Even</span> <span class="n">n</span> <span class="err">→</span> <span class="kt">Even</span> <span class="p">(</span><span class="n">succ</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can prove that $2$ is even by applying the second rule, with $n=0$, to the first rule (telling us that $0$ is even).</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>2 is Even
</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="mi">2</span><span class="n">even</span> <span class="kt">:</span> <span class="kt">Even</span> <span class="mi">2</span>
</span><span class="line"><span class="mi">2</span><span class="n">even</span> <span class="ow">=</span> <span class="o">+</span><span class="mi">2</span><span class="n">even</span> <span class="n">zeroeven</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We next show that $1$ is odd. This means that we have to show that the type $Even 1$ is empty. While rules let us construct objects, and verify their types, there is no rule that tells us directly that a type is empty.</p>

<p>However, there is a nice way of capturing that a type $A$ is empty - if there is a function from $A$ to the empty type $False$, then $A$ must be empty - there is nowhere for an object of type $A$ to be mapped.</p>

<p>Indeed, what we prove is that there is a function from $Even\ 1$ to $False$ ; we define this using an absurd pattern.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>1 is odd
</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="mi">1</span><span class="n">odd</span> <span class="kt">:</span> <span class="kt">Even</span> <span class="mi">1</span> <span class="err">→</span> <span class="kt">False</span>
</span><span class="line"><span class="mi">1</span><span class="n">odd</span> <span class="nb">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="the-identity-type">The identity type</h3>

<p>One of the most fundamental concepts in homotopy type theory is the identity type family, representing equality between objects with a given type. This is an inductive type family, generated by the reflexivity constructor giving an equality between an object and itself.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>The identity type
</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kr">_</span><span class="o">==</span><span class="kr">_</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">refl</span> <span class="kt">:</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="n">a</span> <span class="o">==</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Note that while this is an inductive type family, for a fixed object a the type $a==a$ is <em>not</em> an inductive type defined by $refl(a)$, i.e., we cannot define (dependent) functions on this type but just defining them on the reflexivity constructor. This is a subtle point, which will become clearer as we look at the topological interpretation. We shall study the identity type extensively.</p>

<p>For now, let us show some basic properties of the identity type. All these are proved by constructing objects by pattern matching (recall that these are dependent functions, so we are formally constructing them by induction, not recursion).</p>

<p>Firstly, if $f$ is a function and $a==b$ (i.e., there is an object of type $a==b$), then $f(a)==f(b)$ (again, we mean there is an object of this type). </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Equality under function application
</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">transfer</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="n">x</span> <span class="n">y</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">}</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">B</span><span class="p">)</span> <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="err">→</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</span><span class="line"><span class="nf">transfer</span> <span class="n">f</span> <span class="p">(</span><span class="n">refl</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">refl</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Further, we see that equality (given by the identity type) is symmetric and transitive. </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Symmetry of the equality
</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">symm</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="n">x</span> <span class="n">y</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">}</span> <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="err">→</span> <span class="n">y</span> <span class="o">==</span> <span class="n">x</span>
</span><span class="line"><span class="nf">symm</span> <span class="p">(</span><span class="n">refl</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">refl</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Transitivity of equality
</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">_transEq_</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">}</span> <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="err">→</span> <span class="n">y</span> <span class="o">==</span> <span class="n">z</span> <span class="err">→</span> <span class="n">x</span> <span class="o">==</span> <span class="n">z</span>
</span><span class="line"><span class="p">(</span><span class="n">refl</span> <span class="n">a</span><span class="p">)</span> <span class="n">transEq</span> <span class="p">(</span><span class="n">refl</span> <span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">refl</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>There is a new Agda feature we have used in the proof of transitivity: the <em>dot notation</em>. Notice that we have a term <strong>.a</strong> - this says that we can deduce, <em>from the types</em>, that $a$ is the only possibility at its position in the pattern.</p>

<h3 id="for-all">For all</h3>

<p>Suppose we have a type $A$ and a family of types $P(a)$ (which we regard as propositions), with a type associated to each object $a$ of type $A$. Then all the types $P(a)$ have objects  (i.e., all corresponding propositions are true) if and only if there is a dependent function mapping each object $a$ of type $A$ to an object of type  $P(a)$. Thus, the logical statement</p>

<script type="math/tex; mode=display">\forall a \in A\ P(a)</script>

<p>translates to the product type</p>

<script type="math/tex; mode=display">\prod\limits_{a : A} P(a).</script>

<p>In Agda, we represent the product type as $(a : A) \to P(a)$</p>

<h3 id="a-proof-by-induction">A proof by induction</h3>

<p>We can now prove a more substantial result. Namely, suppose we have a function $f : \Bbb{N}\to \Bbb{N}$ , and suppose for all $n\in \Bbb{N}$ we have $f(n) = f(n+1)$, then we show that, for all $n$, $f(n)=f(0)$.</p>

<p>Such a statement is normally proved by induction (indeed any proof must reduce to induction). We see that our pattern matching rules for constructing dependent functions suffice to prove this - this is why the dependent function that gives them is called the induction function.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>f(n)= f(n+1) for all n implies f is constant
</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">constthm</span> <span class="kt">:</span> <span class="p">(</span><span class="n">f</span> <span class="kt">:</span> <span class="err">ℕ</span> <span class="err">→</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="p">((</span><span class="n">m</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">succ</span> <span class="n">m</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">f</span> <span class="n">m</span><span class="p">))</span> <span class="err">→</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:</span> <span class="err">ℕ</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">f</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line"><span class="nf">constthm</span> <span class="n">f</span> <span class="kr">_</span> <span class="mi">0</span> <span class="ow">=</span> <span class="n">refl</span> <span class="p">(</span><span class="n">f</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line"><span class="nf">constthm</span> <span class="n">f</span> <span class="n">adjEq</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">adjEq</span> <span class="n">n</span><span class="p">)</span> <span class="n">transEq</span> <span class="p">(</span><span class="n">constthm</span> <span class="n">f</span> <span class="n">adjEq</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Let us look at the statement and proof more carefully. Firstly, note that the statement is of the form</p>

<script type="math/tex; mode=display"> (f : \Bbb{N} \to \Bbb{N}) \to P(f) \to Q(f).</script>

<p>As we have seen, the first term is a translation of $\forall f : \Bbb{N} \to \Bbb{N}$, so the statement says that for all functions $f : \Bbb{N} \to \Bbb{N}$ (or any other codomain with obvious modifications), we have $P(f) \to Q(f)$.</p>

<p>This in turn is a translation of $P(f) \implies Q(f)$. So we can regard  $P(f)$ as the hypothesis, for a fixed function $f$,  and $Q(f)$  as the desired conclusion.</p>

<p>The hypothesis P(f) is the statement</p>

<script type="math/tex; mode=display"> (m : \Bbb{N}) \to f(m+1) == f(m)</script>

<p>which is just the statement that for all $m$, $f(m+1)=f(m)$.  Finally, the conclusion $Q(f)$ just says that $f(n)=f(o)$ for all $n$.</p>

<p>We now look at the proof. The two constructors correspond to the base case and the induction step. Here the base case is just $f(0)=f(0)$, which follows from reflexivity of equality.</p>

<p>The induction step is more complicated. We prove the result for $n+1$ assuming the result for $n$. The main hypothesis $\forall m, f(m+1) = f(m)$, is, by pattern matching, $adjEq$. The right hand side, which is the proof in the case of $n+1$, is obtained from:</p>

<ul>
  <li>The hypothesis for $n$,  giving $f(n+1) = f(n).$</li>
  <li>The induction hypothesis, which is the theorem we are proving applied to $n$, giving $f(n)=0.$</li>
  <li>Transitivity of equality.</li>
  <li>The proof is obtained by applying the function corresponding to the transitivity of equality to the two objects corresponding to the other ingredients above.</li>
</ul>

<p>This proof is remarkable in many ways. First of all, note that this is no longer or more complicated than an informal proof. Further, note that we did not have to invoke the usual induction axiom schema, but instead just used the rules for constructing objects. Most significantly, as most of our types are inductive type (or type families), we get recursive definitions and inductive proofs in all these cases.</p>

<p>Indeed,  using recursive definitions for inductive types we get all so called <em>universal properties</em>. Furthermore, traditionally universal properties require a separate uniqueness statement. But recursion-induction is powerful enough to even give the uniqueness statements for universal properties. This means a great deal of mathematical sophistication (universal algebra, various aspects of category theory) are encapsulated in these simple functions.</p>

<h3 id="more-types-for-propositions">More types for propositions</h3>

<p>We now see the types corresponding to the other ways of combining propositions : and, or and there exists.</p>

<p>Firstly, if $A$ and $B$ are types corresponding to propositions, then there are objects with each of these types if and only if there is a pair $(a, b)$ of the pair type $A \times B$, which we define as follows.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Pair type
</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kr">_</span><span class="err">×</span><span class="kr">_</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="p">[</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">]</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">B</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">×</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We have to use square brackets as parenthesis have a special meaning in Agda. Observe that there is a single constructor that takes as input an object in $A$ and an object in $B$. We regard the result as the pair.</p>

<p>Next, suppose $A$ and $B$ are types corresponding to propositions and we wish to construct a type corresponding to $A$ <em>or</em> $B$, then we require a type whose elements are elements of $A$ and elements of $B$, or more accurately the images of such elements under constructors. This is the direct sum type.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Direct Sum type
</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kr">_</span><span class="err">⊕</span><span class="kr">_</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">i</span><span class="err">₁</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">⊕</span> <span class="kt">B</span>
</span><span class="line">  <span class="n">i</span><span class="err">₂</span> <span class="kt">:</span> <span class="kt">B</span> <span class="err">→</span> <span class="kt">A</span> <span class="err">⊕</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Finally, if we are given a collection of types $B(a)$ for objects $a$ of type $A$, we construct the type corresponding to at least one of these types having an element, i.e., a <em>there exists</em> type.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Sigma type
</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="err">Σ</span><span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="p">(</span><span class="kt">B</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
</span><span class="line">  <span class="err">ι</span> <span class="kt">:</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="kt">B</span> <span class="n">a</span> <span class="err">→</span> <span class="err">Σ</span> <span class="kt">A</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Notice that the constructor for this type has as input an element $a$ and an element of type $B(a)$. Such elements exist if and only if some $B(a)$ is non-empty, i.e., the corresponding proposition is true.</p>

<p>As we see, we can express all the usual mathematical statements using types built up using our basic constructions: inductive types, functions and dependent functions. We have also seen that the basic rules for constructing objects are powerful rules of deduction. However, there are some things they cannot deduce, for instance the statement (called the axiom of extensionality) that if $f, g: A\to B$ are function with $f(a)=g(a)$ for all $a \in A$, then $f=g$. Hence, we have to introduce this as a postulate - we just postulate that  there is an object (which we give a name) of a given type.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Axiom of Extensionality
</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">postulate</span>
</span><span class="line">  <span class="n">extensionality</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">g</span> <span class="kt">:</span> <span class="kt">A</span> <span class="err">→</span> <span class="kt">B</span><span class="p">)</span> <span class="err">→</span> <span class="p">((</span><span class="n">x</span> <span class="kt">:</span> <span class="kt">A</span><span class="p">)</span> <span class="err">→</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))</span> <span class="err">→</span> <span class="n">f</span> <span class="o">==</span> <span class="n">g</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We can similarly introduce axioms specific to a domain, say Euclidean geometry, by postulating them in a module.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/01/16/lambda-islands/">Lambda Islands</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/12/dynamical-actors/">Dynamical Actors</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/09/feedbacks/">Feedbacks</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/07/blending-pruning-and-backprop/">Blending Pruning and Backprop</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/02/differentiable-function-combinators/">Differentiable Function Combinators</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/siddhartha-gadgil">@siddhartha-gadgil</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'siddhartha-gadgil',
            count: 4,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>



<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/+SiddharthaGadgil?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Siddhartha Gadgil -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'logictypesandspaces';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
